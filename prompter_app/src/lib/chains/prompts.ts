import type { ComponentType } from "svelte";
import PromptBoxRenderedPromptSpinner from "../../components/chainEditor/PromptBoxRenderedPromptSpinner.svelte";
import { StepType, type PromptStep, type StepResult, type PromptChain } from "./chains";
import { RunStatus, type StepRunStatus } from "../prediction/chain";
import { escapeHtml } from "../util";
import nunjucks from 'nunjucks';
import { PredictionService, defaultPredictionSettings } from "../services";
nunjucks.configure({autoescape: false, trimBlocks: true});
nunjucks.installJinjaCompat();

export function getDefaultPrompt(resultKey: string): PromptStep {
  return {
      stepType: StepType.prompt,
      promptText: "{# This is an example prompt: replace it with your own! #}\n\nTell me a short (less than {{ maxWords }} words) story about {{ storyTopic }}.\n\n{% if anotherTopic %}\nAnd another one about {{ anotherTopic | upper }}!!!\n{% endif %}",
      title:  "Untitled Prompt",
      resultKey: resultKey,
      results: null,
      minimized: false,
      predictionService: PredictionService.openai,
      predictionSettings: defaultPredictionSettings()
  }
}

export function getExamplePrompt(resultKey: string, promptChain: PromptChain, position: number): PromptStep {
  let result = getDefaultPrompt(resultKey);

  // Customise example based on the new prompt position
  if (position == 0) result.promptText = "{# This is an example additional step: try using its result key as a variable in the next ones! #}\n\nProduce a JSON object describing the properties of a character in a story about {{ storyTopic }}"
  else {
      const previousResultKey = promptChain.steps[position-1].resultKey
      result.promptText = "{# This is an example additional step: you can use previous result keys here! #}\n\nProduce a short poem about the following text that was generated by an AI model:\n\n{{"+previousResultKey+"}}";
  }

  return result;
}

/*
 * Template rendering
 */

export function renderTemplate(template: string, paramDict: Record<string, string>): string {
    let result = template;
    result = nunjucks.renderString(template, paramDict);
    return result.trim();
  }

// ["string", null]
// [AnySvelteComponent, {its: "props"}]
export type ComponentAndProps = [ComponentType | string, Record<string, any> | null];

export interface RenderedPromptResult {
    text: string,
    html: string,
    components: ComponentAndProps[]
}

export function renderPrompt(
    prompt: PromptStep,
    paramDict: Record<string, string>,
    previousResults: Record<string, StepResult | null>,
    predictionStatus: Record<string, StepRunStatus>
) : RenderedPromptResult {
    // console.log("render: ", prompt.promptText);
    let resultComponents: ComponentAndProps[] = [];
    let resultHtml: string;
    let resultText: string;

    // https://regex101.com/r/WhYBv9/2
    const jinjaRegex = /(\{\{\s*(\w+)\s*(?:\|\s*(?:[\w]+\(".*?"\)|[\w]+\('.*?'\)|.*?)\s?\}\}|\}\}))/gi;
    const spinnerTag = "<i class=\"prompter spinner\"></i>"; // Will be replaced with spinner component

    resultHtml = prompt.promptText.replace(jinjaRegex, (match, _, matchedParamName) => {
    if (previousResults[matchedParamName] !== undefined) {
        let resultValue;
        let resultSpinner = "";
        if (
        predictionStatus[matchedParamName]?.status == RunStatus.onHold ||
        (predictionStatus[matchedParamName]?.status == RunStatus.inProgress && ! previousResults[matchedParamName])
        ) {
        resultValue = "";
        resultSpinner = spinnerTag;
        } else {
        resultValue = (previousResults[matchedParamName]) ? match : ' - ';
        }
        return '<span class="previousResult">' +
                '<span class="resultKey">ðŸ”‘ '+matchedParamName+'</span>' +
                resultValue +
                '</span>' + resultSpinner;
    }
    return '<span class="param">' + match + '</span>'
    });

    // TODO: move sanitization at dict level
    let renderedParamDict: Record<string, string> = {};
    for (const paramName in paramDict) {
    renderedParamDict[paramName] = escapeHtml(paramDict[paramName] ?? '');
    }
    for (const resultKey in previousResults) {
    if (previousResults[resultKey] != null) {
        renderedParamDict[resultKey] = (previousResults[resultKey] as StepResult).resultRaw;
    }
    }
    resultText = renderTemplate(prompt.promptText, renderedParamDict);
    resultHtml = renderTemplate(resultHtml, renderedParamDict);

    // Replace spinner tag with spinner component
    const spinnerSplit = resultHtml.split(spinnerTag);
    if (spinnerSplit.length > 1) {
      for (let i=0; i < spinnerSplit.length-1; i++) {
        resultComponents.push([spinnerSplit[i], null]);
        resultComponents.push([PromptBoxRenderedPromptSpinner, {}]);
      }
    }
    resultComponents.push([spinnerSplit[spinnerSplit.length-1], null]);

    return {
        text: resultText,
        html: resultHtml,
        components: resultComponents
    };
}